# 비밀지도

<p>문제 출처 : <a link="https://programmers.co.kr/learn/courses/30/lessons/17681?language=java">프로그래머스</a></p>

<li>
  <ol>지도는 한 변의 길이가 <font-color:"blue"><b>n</b></font>인 정사각형 배열 형태로, 각 칸은 "공백"(" ")
      또는 "벽"("#") 두 종류로 이루어져 있다.
  </ol>
  <ol> 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느
       하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. 
  </ol>
  <ol> "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다. </ol>
  <ol> 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 <b>1</b>, 공백 부분을 <b>0</b>으로 부호화했을 때 얻어지는 이진수에
       해당하는 값의 배열이다.
  </ol>
</li>

![비밀 지도][imgs]
[imgs] : http://t1.kakaocdn.net/welcome2018/secret8.png "비밀지도 예시"

### 입력 형식
입력으로 지도의 한 변 크기 <b>n</b>과 2개의 정수 배열 <b>arr1</b>, <b>arr2</b>가 들어온다.
<li>
  <ul>1 <= <b>n</b> <= 16</ul>
  <ul> <b>arr1</b>, <b>arr2</b>는 길이 <b>n</b>인 정수 배열로 주어진다. </ul>
  <ul> 정수 배열의 각 원소 <b>x</b>를 이진수로 변환했을 때의 길이는 <b>n</b> 이하이다.
       즉, 0 <= <b>x</b> <= 2^n - 1을 만족한다.
  </ul>
</li>

### 출력 형식
원래의 비밀지도를 해독하여 <b>'#'</b>, <b>공백</b>으로 구성된 문자열 배열로 출력하라.

### 입출력 예제
<table>
<tr><td>매개변수</td><td>값</td></tr>
<tr><td> n </td><td> 5 </td></tr>
<tr><td> arr1 </td><td> [9, 20, 28, 18, 11] </td></tr>
<tr><td> arr2 </td><td> [30, 1, 21, 17, 28] </td></tr>
<tr><td> 출력 </td><td> ["#####", "# # #", "### #", "# ##", "#####"] </td></tr>
</table>

<table>
<tr><td>매개변수</td><td>값</td></tr>
<tr><td> n </td><td> 6 </td></tr>
<tr><td> arr1 </td><td> [46, 33, 33, 22, 31, 50] </td></tr>
<tr><td> arr2 </td><td> [27, 56, 19, 14, 14, 10] </td></tr>
<tr><td> 출력 </td><td> ["######", "###  #", "##  ##", "#### ", "#####", "### # "] </td></tr>
</table>

*** 특이사항 : 배열의 길이가 6인 예제 결과가 프로그래머스에서는 위와 다르게 나와있다. 하지만 스터디에서는 위 결과를 기준으로 출력하라

** Tip : 비트 연산자를 사용 추천 (ex-> int num = n1 & n2)
<p> 연산자 종류 </p>
<li>
  <ul> A&B : A 비트와 B비트를 비교하여 양쪽 모두 1이면 1을 반환, 아니면 0을 반환</ul>
  <ul> A|B : A 비트와 B비트를 비교하여 어느 한쪽이 1이면 1을 반환, 아니면(둘다 0이면) 0을 반환 </ul>
  <ul> A^B : A 비트와 B비트를 비교하여 한쪽이 1이고 다른 한쪽이 0이면 1을, 아니면 0을 반환 </ul>
  <ul> ~A : A비트의 1의 보수(not)를 반환 </ul>
</li>
